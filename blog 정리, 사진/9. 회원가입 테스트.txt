1. 회원가입 과정을 확인하기 위한 간단한 test 진행
    사진 1번과 같이 @RestController를 이용하여 body에 username, password, email 데이터를 가지고 요청.

    사진 2번을 보면 x-www-form-urlencoded를 선택하여 데이터를 입력하였는데, x-www-form-urlencoded는 데이터를 key=value 형태로 전송하게 된다.(key=value의 연결은 &으로 한다.)
    이때 STS의 console창을 확인하면 데이터가 정확히 전송된 것을 볼 수 있다.(사진 3번)

    이러한 과정을 오브젝트로 받아서 사용할 수 있다.(사진 4번)
    물론, User에 존재하는 나머지(id, role, createdate)는 none 값으로 들어오게 된다.(사진 5번)

    이 상태에서 데이터 베이스 인서트를 하기 위해서는 새로운 패키지가 필요하다.(사진 6번)

    JpaRepository<User, Integer> : 해당 JpaRepository는 User table이 관리하는 저장소(Repository)이고, User table의 프라이머리티(키 ?)는 Integer(숫자 형태)라는 뜻이다.
                                    JpaRepository는 findAll()이라는 함수를 들고 있으며 이것은 해당하는 table의 모든 행을 return하라는 뜻이다.(그 외에도 삭제, 수정 등을 수행할 수 있다.)
                                    즉, 데이터의 생성, 수정, 삭제를 이것 하나로 해결할 수 있으며 자동으로 bean에 등록된다.(@Repositroy를 생략해도 된다.)

    이렇게 만든 코드(사진 7번)를 사용하기 위해서는 DummycontrollerTest.java에서 @Autowired를 사용하여 UserRepositroy를 인스턴스화하면 된다.(사진 8번)
    그리고 UserRepositroy.save()를 이용하여 작성된 내용을 데이터 베이스에 저장할 수 있다.(사진 9번)
        사진 9번에서 role을 보면 null값이 들어간 것을 확인할 수 있다.
        다른 데이터들은 작성된 내용을 받아오거나 자동으로 값을 받아서 들어오게 되는데 사진 10번에서 확인되는 것과 같이 디폴트값을 user로 받고 있다.
        이 user 값은 username, password, email을 받아와야 생성되는 것이다.
        즉, null값이 없이 작동하기 위해서는 role을 제외한 상태에서 UserRepositroy.save()가 동작해야한다.
        이 문제를 해결하기 위한 방법이 @DynamicInsert를 사용하는 것이다.(@DynamicInsert는 insert 할 때, null인 필드를 제외해준다.) -> 사진 11번과 같이 User class에 사용한다.
        @DynamicInsert를 사용하고 다시 요청을 하게되면 사진 12번과 같이 role을 받아오던 것이(console창에서 확인) 사진 13번처럼 null값을 제외하고 받아오는 것을 확인할 수 있다.
        (데이터 베이스에도 role 자리에 user가 들어오는 것을 확인할 수 있다.)

    하지만 null값이 들어가지 않아야 할 