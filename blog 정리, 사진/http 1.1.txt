1. http 1.1이란?
    A와 B가 서로 통신을 하게 될 때, 이 통신은 Byte Stream(8bit)로 이뤄지며 A가 B로(A -> B) write, B에서 A로(B -> A) Read 할 수 있다. 이것이 일반적인 통신이다.
    (B가 서버(갑, 데이터를 가지고 있음)라고 한다면 서버(B)의 입장에서는 클라이언트(A)가 누구인지 궁금하지 않다. A가 B에게 요청(request)하게 된다면 B는 A에게 응답(response)하게 된다.)

    http 통신을 하게된다면 어떠한 약속이 필요한데 그 중에 http 1.1의 약속 중 통신 방법의 4가지 법칙(요청의 방법)이 있다.
        1-1. Get : 데이터를 받아올 수 있는 요청. - Select(A가 B에게 데이터를 요청하면 B는 그것에 대해 응답해야한다.)
        1-2. Post : 데이터의 추가를 요청. - Insert(회원가입을 하고 로그인을 하게 되면 웹브라우저에 내 정보를 서버에 넘겨줌.)
        1-3. Put : 데이터의 수정을 요청. - Update(회원정보의 수정 등)
        1-4. Delete : 데이터의 삭제를 요청. - Delete(회원정보의 삭제 등)

        이처럼 요청을 할 수 있지만 어떤 데이터를 요청한 것이지는 모른다. 그렇기 때문에 통신을 할 때
        '요청?how'와 같이 요청(Get, Post, put, Delete) 뒤에 '?'를 추가하여 요청할 데이터를 넣어준다.

2. stateless란?
    만약, A(클라이언트)와 B(서버)가 서로 통신을 하여 연결이 끊이지 않고 계속 유지되고 있다면, 다른 클라이언트가 B와 통신을 시도할 경우 서버에 부하가 생긴다.
    이렇게 끊이지 않고 지속되는 통신은 채팅에서 많이 사용한다.(stateful 방식)

    반면, http와 같은 데이터를 요청하는 경우에는 A의 요청을 응답한 B는 스트림 연결을 끊어버린다. 이러한 방식을 stateless라고 한다.

    stateful 방식의 경우는 연결이 지속되어 있기 때문에 세션(데이터 사용 권한 인증)이 유지되지만, stateless 방식의 경우는 연결이 끊기기 때문에 데이터를 요청할 때마다 세션 인증을 다시 진행해야한다.
    이것을 해결하기 위한 방법(security)는 차후에 알아보도록 하자.

3. MIME타입이란?
    클라이언트(A)가 서버(B)에게 Post 요청을 한다면 클라이언트는 수정할 내용을 헤더(Header)에는 수정할 내용을 담고 있는 경로(데이터를 설명해주는 내용), 바디(Body)에는 수정할 내용의 파일(실제 데이터)을 담아서 요청해야한다.
    이때의 헤더를 http 헤더, 바디를 http 바디라고 부른다.

    헤더에는 일반적으로 여러 가지 내용이 들어갈 수 있는데
        http 통신을 할 때, 패킷 스위칭 통신 방식을 사용한다. 이것을 이해하기 위해서는 서킷 스위칭 방식을 이해하고 있어야 한다.
            서킷 스위칭 방식(Circuit-Switching) : 간단한 예를 들자면 [a, b, c, d]라는 데이터가 존재할 때, A에서 B로 한 방에 실어서 전송을 한다.(A-> B)
                                                속도가 굉장히 빠른 대신에 다른 클라이언트가 전송을 하게되면 새로운 통신을 개방해야하기 때문에 비용이 많이 든다.(C -> B)
            패킷 스위칭 방식(Packet-Switching) : 서킷과 달리 [a, b, c, d]라는 데이터를 A에서 B로 전송할 때, [a], [b], [c], [d]로 분리하고 이때 분리된 하나하나의 데이터를 패킷이라고 부른다.
                                                A는 이렇게 잘개 쪼개진 패킷을 B에 전송하게 된다.
                                                이 경우에는 다른 클라이언트가 데이터를 전송하게 될 때, A가 전송한 경로를 따라 패킷을 전송한다.(C ->(A가 사용하던 경로) B)

                                                이렇게 패킷으로 분할된 데이터를 받게 된다면 B는 받은 패킷을 다시 조립해야한다.
                                                물론, 같은 경로를 이용하여 패킷을 받았기 때문에 무작위로 섞여있는 패킷을 분간하여 조립해야한다.

                                                이때, 수만가지의 경로를 통해 전달되는 패킷은 보낸 순서와 상관없이 도달할 수 있는데 이 순서를 정확하게 맞추기 위해 헤더에 데이터의 순서, 보낸 클라이언트 등의 정보를 포함한다.

                                                즉, 헤더에 담길 수 있는 내용은 어떤 것이든 들어갈 수 있기 때문에 작성 방식이 따로 정해져있다. 이 방식을 바로 'MIME' 라고 한다.

    MIME 타입이란 Multipurpose Internet Mail Extensions의 약자로 간단히 말하면 파일 변환을 의미한다.(클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘입니다.)
    웹에서 파일의 확장자는 별 의미가 없습니다. 그러므로, 각 문서와 함께 올바른 MIME 타입을 전송하도록, 서버가 정확히 설정하는 것이 중요합니다. 
    브라우저들은 리소스를 내려받았을 때 해야 할 기본 동작이 무엇인지를 결정하기 위해 대게 MIME 타입을 사용합니다.

        문법 : '/'로 구분된 두 개의 문자열인 타입과 서브타입으로 구성됩니다. (type/subtype)
                스페이스는 허용되지 않습니다. type은 카테고리를 나타내며 개별(discrete) 혹은 멀티파트 타입이 될 수 있습니다. subtype 은 각각의 타입에 한정됩니다.
                MIME 타입은 대소문자를 구분하지는 않지만 전통적으로 소문자로 쓰여집니다.

                ex) text/plain, text/html, image/jpeg, image/png, audio/mpeg, audio/ogg, audio/*, video/mp4, application/octet-stream

                * 타입을 모두 외울 필요 없이 https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types에서 찾아 사용.

4. Controller 생성 및 실습

    실습을 위해 test를 위해 만들었던 spring 패키지에서 새로운 클래스를 만든다.(사진 1번)
    이것이 컨트롤러가 되기 위해서 어노테이션이 필요하다.(사진 2번)
        - 사용자가 요청 -> 응답(HTML 파일) = @Controller
        - 사용자가 요청 -> 응답(Data) = @RestController
    정상적으로 작동하는지 확인하기 위해 사진 3번과 같이 요청 방식을 달리하여 작성.
    spring boot app을 실행하고 서버에 들어가면 입력해놓은 출력이 뜨는 것을 확인할 수 있는데, 여기서 작업 관리자에 들어가 Network에서 f5를 누르면 사진 4번과 같이 현재 페이지를 어떤 방식으로 요청했는지 볼 수 있다.
        - General(사진 5번)
            - Request Method : 요청 방식을 확인할 수 있다.
            - Status Code : 서버의 응답 상태를 확인할 수 있다.
        - Response Headers (서버가 어떻게 response 해주었나, 사진 6번)
            - Content-Type : 요청에 응답을 어떤 타입을 어떤 서브타입으로(type/subtype) 했으며, 그 응답이 무엇으로 인코딩 되어있는가.
        - Request Headers(내가 웹브라우저를 통해서 서버에게 요청할 때의 헤더, 사진 7번)

    get 요청과 달리 post 요청은 Whitelabel Error Page가 뜨며, 작업 관리자에서는 405로 나온다.(사진 8번)
    여기서 405 에러는 해당 메소드가 허용되지 않는다는 에러이다.(사진 9번)
    put과 delete 요청도 마찬가지로 에러 발생.(사진 10, 11번)

    즉, 인터넷 브라우저 요청은 무조건 get 요청밖에 할 수 없다.

    이런 에러를 무시하고 보기 위해 필요한 것이 postman이다.(사진 12번)
        - postman 활용(사진 13, 14, 15, 16번). 요청을 변경하기 위해서는 url 기입창 옆 request를 요청에 맞게 변경해줘야한다.